m在First和Second中都有定义但是不是虚函数，所以没有覆盖在这里也不是重载，而是属于两个不同类的函数，在具体调用的时候首先是根据函数名称即标识符来查看调用哪个类中的m函数，这个查找过程是是又一定的名字查找规则的，尤其是在多重继承中体现更明显，在C++编程思想第二卷P374中有具体查找规则描述；确定类了之后再选择函数具体的重载形式，比如如果在First中m还有一个参数为int的重载形式，而在Second中没有，但是在调用的时候使用p->m(1)调用，在这个例子的情形下就会报错，因为根据名称查找规则确定是使用Second类中的m函数，但是这个类中没有参数为int的重载形式，如果这在Second中重载了这种形式则肯定没有问题；同样在Second类中如果不定义m则也没有问题，因为这个时候在名称查找的时候就会确定的是使用First类中的m函数，而在First类中恰好有m的int参数的重载形式，所以就不会报错，只是这个时候就会调用First类中的m函数了。
多重继承的情况，会为每一个基类建一个虚函数表。派生类的虚函数放到第一个虚函数表的后面。
